### 2217 로프
그리디로 해결하는 문제 
ropes(로프가 버틸수 있는 중량을 담은 배열)를 내림차순으로 정렬하고
for문을 돌면서 제일 성능이 좋은 로프부터 시작해서 max_w(최대 중량) 값을 아래와 같이 수정해 나갔다.

    if new_max_w >= max_w:
        max_w = new_max_w
    else:
        break

근데 틀렸다고 뜬다..  
이유는? else문 때문이였다. else문에서 한번이라도 new_max_w가 작아졌으면 for문을 빠져나오도록 했었다. 그런데 그렇게 하면 안됐다. new_max_w가 작아졌어도 뒤에 수많은 로프들이 있다면 new_max_w가 다시 max_w 보다 커지는 경우가 생기기 때문이다!

결론: Greedy로 문제를 풀 때는 상식적으로 보다는 극단적으로 생각해보는 게 도움이 될지도..
<br/>
<br/>
### 13305 주유소
핵심: 각 도시 주유소의 기름값을 담고있는 prices리스트는 내림차순으로 되어야 한다!  

예를 들어 각 도시의 주유소 값이 [5, 2, 4, 1] 이면 값이 4인 곳(index:2)에서는 주유를 할 필요가 없으므로 [5,2,2,1] 과 같은 내림차순의 형태로 된다고 생각하면 편리하다.  

내 코드에서는 prices리스트를 건들지 않고, 도시간의 거리를 담고 있는 road_lens 리스트에서 해당하는 값(index:2)을 0으로 맞춰 주었다.([2,3,1] -> [2,4,0])
개념적으로 기름값이 2~1인 지점을 하나로 묵었다고 생각하면 편하다. [5,2,4,1] -> [5,2,1]
<br/>
<br/>
### 1931 회의실 배정
처음짠 코드는 O(n^2) 복잡도를 가지는 이중 for문을 사용했다. => 시간초과가 떴다! 

애초에 n의 값이 10,000이기 때문에 O(n*log n)보다 적게 나오도록 풀어야 됐다. 문제 풀기전부터 이런 것들을 고려해서 접근했어야 됐다. (O(n^2)은 N이 2000이하인 경우 가능)

그렇다면 어떻게 접근을 했어야 하는가?
sort함수는 O(n*log n)이기 때문에 sort 할 때부터 어느정도 완성되도록 해야 한다.
그리고 회의의 개수가 최대가 되려면 '종료시간'을 중요하게 생각하여 정렬한다. 그리고 회의시간이 0인 친구들(예를들면 (5,5))을 생각했을때는 시작시간을 기준으로 한번 더 정렬을 해야 한다.

결론: 사실 처음부터 이런 아이디어를 떠올리는 건 자신없다. 결국 문제를 많이 풀어서 유형을 익혀야 될것 같다.